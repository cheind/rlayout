
require 'logger'

module RLayout

  # Implements the process of exporting a virtual file system.
  #
  # The runtime is responsible for traversing the virtual file system, 
  # managing reading from nodes and writing to exporters. The runtime implements
  # a single read/multiple write architecture that allows node content to be read
  # once and passed to multiple exporters.
  #
  class Runtime
    # Registered exporters
    attr_reader :exporters
    
    # Custom formatting of log messages
    class ErrorFormatter
      # Format to be used
      Format = 	"%5s -- %s\n"
      
      # Format log entry
      def call(severity, time, program_name, message)
        Format % [severity, message]
      end
    end
    
    # Construct from options
    #
    # === Supported Options
    # * <tt>:log</tt> - Instance of logger to be used.
    # * <tt>:log_level</tt> - The logging level to be used.
    # * <tt>:cleanup</tt> - Cleanup files generated by exporters in case of an error
    #
    def initialize(opts = {})
      @opts = {
        :log => Logger.new(STDOUT), 
        :log_level => Logger::INFO,
        :cleanup => true
      }.merge(opts)
      
      @logger = @opts[:log]
      @logger.level = @opts[:log_level]
      @logger.progname = 'RLayout'
      @logger.formatter = ErrorFormatter.new
      @exporters  = []
    end
    
    # Start parsing the VFS tree at <tt>root</tt>.
    #
    # === Supported Options
    # * <tt>:dry_run</tt> - Run without reading or writing data but with verbose output.
    # * <tt>:chunksize</tt> - Requested blocksize per read.
    # * <tt>:cleanup_on_error</tt> - If true, invokes Exporters#Exporter#cleanup in case of an error.
    # * <tt>:reraise_errors</tt> - If true, any error occurred is re-raised after possible treatment.
    #
    def run(root, opts={})
      @run_opts = {
        :dry_run => false,
        :chunksize => 1024
      }.merge(opts)
      
      @logger.info('Starting.')
      
      begin
        init_tags = self.prologue(root)
        RLayout.vfs_preorder(
          root, 
          init_tags,
          :unroll_incomplete => true, 
          &self.method(:process)
        )
        self.epilogue
        @logger.info('Finished.')
      rescue StandardError => err
        @logger.fatal(err.message)
        if @opts[:cleanup]
          @logger.info('Cleaning up.')
          self.cleanup
        end
        @logger.info('Failed.')
        raise err
      end
    end
    
    protected
    
    # Inform exporters that parsing is about to start.
    #
    # Values returned from Exporters#Exporter#prologue are considered
    # to be tags for <tt>root</tt>.
    def prologue(root)
      init_tags = []
      self.send_each(@exporters, :prologue, root, @run_opts) do |ret|
        init_tags << ret
      end
      init_tags
    end
    
    # Process a <tt>node</tt> and associated <tt>tags</tt>.
    def process(node, tags)
      if node.kind_of?(VFSGroup)
        process_group(node, tags)
      elsif node.kind_of?(VFSStreamableNode)
        process_leaf(node, tags)
      else
        process_other(node)
      end
    end
    
    # Process a group <tt>node</tt> along with exporter <tt>tags</tt>.
    #
    # Values returned from Exporters#Exporter#group are considered tags 
    # for the child nodes of <tt>node</tt>.
    #
    def process_group(node, tags)
      next_tags = []
      @exporters.each_with_index do |e, i|
        next_tags << e.group(node, tags[i])
      end
      next_tags
    end
    
    # Process a streamable leaf node.
    #
    # Each registered Exporters#Exporter is asked if it wheter likes to participate 
    # in streaming the leaf pointed to by <tt>node</tt> or not. In case it is, Exporters#Exporter 
    # should return an instance Exporters#StreamHandler, nil otherwise.
    #
    # The Runtime implements a single-read/multiple write architecture, therefore the following
    # methods are called after each method was invoked for all handlers.
    # 
    # * Exporters#StreamHandler#open - Start of node processing.
    # * Exporters#StreamHandler#write - Called for each block read from <tt>node</tt>
    # * Exporters#StreamHandler#close - End of node processing. Called even in case of an error.
    #
    def process_leaf(node, tags)
      chunksize = @run_opts[:chunksize]
      handlers = []
      @exporters.each_with_index do |e, i|
        h = e.leaf(node, tags[i])
        handlers << h if h
      end
      unless handlers.empty?
        self.send_each(handlers, :open, node)
        begin
          node.read_stream(chunksize) do |bytes|
            self.send_each(handlers, :write, bytes)
          end
        ensure
          self.send_each(handlers, :close, node)
        end
      end
    end
    
    # Process an unrecognized node.
    # Invokes Exporters#Exporter#other for each exporter.
    #
    def process_other(node, tags)
      @exporters.each_with_index do |e, i|
        e.other(node, tags[i])
      end
    end
    
    # Invoke Exporters#Exporter#epilogue for each exporter.
    #
    def epilogue
      self.send_each(@exporters, :epilogue)
    end
    
    # Invoke Exporters#Exporter#cleanup for each exporter.
    #
    def cleanup
      self.send_each(@exporters, :cleanup)
    end
    
    # Invoke <tt>method_name</tt> along with <tt>*args</tt> on each element 
    # in <tt>collection</tt>.
    #
    def send_each(collection, method_name, *args)  # :yield: result of each invocation
      collection.each do |e|
        result = e.send(method_name, *args)
        yield result if block_given?
      end
    end
    
  end
  
end
